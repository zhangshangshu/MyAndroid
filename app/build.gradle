apply plugin: 'com.android.application'

android { //是Android插件提供的一个扩展类型，可以让我们自定义Android Gradle工程，是Android Gradle工程配置的唯一入口。
    compileSdkVersion 27 //是编译所依赖的Android SDK的版本，这里是API Level。
    defaultConfig { //defaultConfig是默认的配置，它是一个ProductFlavor。ProductFlavor允许我们根据不同的情况同时生成多个不同的apk包。
        applicationId "com.zss.myandroid"
        //配置我们的包名，包名是app的唯一标识，其实他跟AndroidManifest里面的package是可以不同的，他们之间并没有直接的关系。
        //package指的是代码目录下路径；applicationId指的是app对外发布的唯一标识，会在签名、申请第三方库、发布时候用到。
        minSdkVersion 15 //是支持的Android系统的api level，这里是15，也就是说低于Android 15版本的机型不能使用这个app。
        targetSdkVersion 27 //表明我们是基于哪个Android版本开发的，这里是27。
        versionCode 1 //表明我们的app应用内部版本号，一般用于控制app升级，当然我在使用的bugly自动升级能不能接受到升级推送就是基于这个。
        versionName "1.0" //表明我们的app应用的版本名称，一般是发布的时候写在app上告诉用户的，这样当你修复了一个bug并更新了版本，别人却发现说怎么你这个bug还在，
        // 你这时候就可以自信的告诉他自己看下app的版本号。（亲身经历在撕逼的时候可以从容的应对）
        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"

//        multiDexEnabled true //用于配置该BuildType是否启用自动拆分多个Dex的功能。一般用程序中代码太多，超过了65535个方法的时候。

//        ndk{ //多平台编译，生成有so包的时候使用，包括四个平台'armeabi', 'x86', 'armeabi-v7a', 'mips'。一般使用第三方提供的SDK的时候，可能会附带so库。
//            //设置支持的SO架构
//            abiFilters 'armeabi','x86','armeabi-v7a','x86_64'
//        }
    }

//    //源代码集合，是Java插件用来描述和管理源代码及资源的一个抽象概念，是一个Java源代码文件和资源文件的集合，
//    //我们可以通过sourceSets更改源集的Java目录或者资源目录等。
//    //我通过sourceSets告诉了Gradle我的关于jni so包的存放路径就在app/libs上了，叫他编译的时候自己去找。
//    sourceSets{
//        main{
//            jniLibs.srcDirs = ['libs']
//        }
//    }

    buildTypes {//构建类型，在Android Gradle工程中，它已经帮我们内置了debug和release两个构建类型，
        // 两种模式主要车别在于，能否在设备上调试以及签名不一样，其他代码和文件资源都是一样的。
        // 一般用在代码混淆，而指定的混淆文件在下图的目录上，minifyEnabled=true就会开启混淆：
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
//            zipAlignEnabled true //Zipalign优化
//            shrinkResources true //移除无用的resource文件
        }
//        debug {
//            minifyEnabled false
//            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
//        }

        //name：build type的名字
        //applicationIdSuffix：应用id后缀
        //versionNameSuffix：版本名称后缀
        //debuggable：是否生成一个debug的apk
        //minifyEnabled：是否混淆
        //proguardFiles：混淆文件
        //signingConfig：签名配置
        //manifestPlaceholders：清单占位符
        //shrinkResources：是否去除未利用的资源，默认false，表示不去除。
        //zipAlignEnable：是否使用zipalign工具压缩。
        //multiDexEnabled：是否拆成多个Dex
        //multiDexKeepFile：指定文本文件编译进主Dex文件中
        //multiDexKeepProguard：指定混淆文件编译进主Dex文件中
    }

//    //签名配置，一个app只有在签名之后才能被发布、安装、使用，签名是保护app的方式，标记该app的唯一性。
//    // 如果app被恶意删改，签名就不一样了，无法升级安装，一定程度保护了我们的app。
//    //而signingConfigs就很方便为我们提供这个签名的配置。
//    // storeFile签名文件，
//    // storePassword签名证书文件的密码，
//    // storeType签名证书类型，
//    // keyAlias签名证书中秘钥别名，
//    // keyPassword签名证书中改密钥的密码。
//    signingConfig{
//        //默认情况下，debug模式的签名已经被配置好了，使用的就是Android SDK自动生成的debug证书，
//        // 它一般位于$HOME/.android/debug.keystore,其key和密码是已经知道的，一般情况下我们不需要单独配置debug模式的签名信息。
//        debug{
//            storeFile file("../key/xxx_1.keystore")
//            storePassword "136325"
//            keyAlias "zss"
//            keyPassword "136325"
//        }
//        release{
//            storeFile file("../key/xxx_2.keystore")
//            storePassword "136325"
//            keyAlias "zss"
//            keyPassword "136325"
//            //自定义输出配置
//            applicationVariants.all {
//                variant ->
//                    variant.outputs.all {
//                        outputFileName = "xxx.apk"
//                    }
//            }
//        }
//    }

//    //顾名思义就是维度，Gradle3.0以后要用flavorDimensions的变量必须在defaultConfig{}中定义才能使用，不然会报错。
//    //这样我们就可以在不同的包中形成不同的applicationId和versionName了。
//    flavorDimensions "applicationId"
//    flavorDimensions "versionName"
//    productFlavors{//在我看来他就是Gradle的多渠道打包，你可以在不同的包定义不同的变量，实现自己的定制化版本的需求。
//        GZ_test {
//            applicationId "com.zss.gz_test"
//            versionName "0.7.58"
//            manifestPlaceholders = [APP_NAME:"测试"]//占位符，我们可以通过它动态配置AndroidManifest文件一些内容，譬如app的名字：
//                                                   //<application android:label="${APP_NAME}"
//                                                   // 我们就能控制每个包打出来的名字是我们想要不同的名字，譬如测试服务器和生产服务器的包应该名字不一样。
////           //多个用逗号隔开
////            manifestPlaceholders = [
////                    qq_id: qq_id,
////                    JPUSH_PKGNAME : applicationId,
////                    JPUSH_APPKEY : "xxxxxx", //JPush 上注册的包名对应的 Appkey.
////                    JPUSH_CHANNEL : "developer-default", //暂时填写默认值即可.
////            ]
//
//            //buildConfigField是BuildConfig文件的一个函数，而BuildConfig这个类是Android Gradle构建脚本在编译后生成的。
//            // 而buildConfigField就是其中的自定义函数变量，我们分别定义了三个常量：
//            buildConfigField "String","BASE_URL",'"http://xx.xxx.com/"'
//            buildConfigField "String","VERSION","\"GZ\""
//            buildConfigField "boolean","isTest","true"
//            //我们可以在BuildConfig文件中看到我们声明的三个变量
//        }
//        GZ_verification {
//            applicationId "com.zss.gz_verification"
//            versionName "1.5.8"
//            manifestPlaceholders = [APP_NAME:"测试"]
//            buildConfigField "String","BASE_URL",'"http://xx.xxx.com/"'
//            buildConfigField "String","VERSION","\"GD\""
//            buildConfigField "boolean","isTest","true"
//        }
//    }

    testOptions {
        dexOptions {//我们知道，Android中的Java源代码被编译成class字节码后，在打包成apk的时候
            //被dx命令优化成Android虚拟机可执行的DEX文件。DEX文件比较紧凑，Android费尽心思
            //做了这个DEX格式，就是为了能使我们的程序在Android中平台上运行快一些。对于这些生成
            //DEX文件的过程和处理，Android Gradle插件都帮我们处理好了，Android Gradle插件会调用
            //SDK中的dx命令进行处理。但是有的时候可能会遇到提示内存不足的错误，大致提示异常是
            //java,lang.OutOfMemoryError: GC overhead limit exceeded,为什么会提示内存不足呢？ 其实这个
            //dx命令只是一个脚本，它调用的还是Java编写的dx.jar库，是Java程序处理的，所以当内存
            //不足的时候，我们会看到这个Java异常信息.默认情况下给dx分配的内存是一个G,也就是 1024MB。
            //所以我们只需要把内存设置大一点，就可以解决这个问题，上图我的项目就把内存设置为4g。
            incremental true
            javaMaxHeapSize "4g"
        }
    }
}

dependencies {
    //这样配置之后本地libs文件夹下的扩展名为jar的都会被依赖，非常方便。
    implementation fileTree(include: ['*.jar'], dir: 'libs')
    //如果你要引入某个本地module的话，那么需要用compile project('×××')。
    //如果要引入网上仓库里面的依赖，我们需要这样写compile group：'com.squareup.okhttp3',name:'okhttp',version:'3.0.1',
    //当然这样是最完整的版本，缩写就把group、name、version去掉，然后以":"分割即可。
    //如compile 'com.squareup.okhttp3:okhttp:3.0.1'
    implementation 'com.android.support:appcompat-v7:27.1.1'
    implementation 'com.android.support.constraint:constraint-layout:1.1.2'
    implementation 'com.android.support:support-v4:27.1.1'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'com.android.support.test:runner:1.0.2'
    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
    implementation 'com.tencent.bugly:crashreport:latest.release'
    //    api 'io.reactivex:rxjava:1.0.14'
    //    api 'io.reactivex:rxandroid:1.0.1'
    //到了gradle3.0以后build.gradle中的依赖默认为implementation，而不是之前的compile。另外，还有依赖指令api。
    //gradle 3.0中依赖implementation、api的区别：
    //其实api跟以前的compile没什么区别，将compile全部改成api是不会错的；
    //而implementation指令依赖是不会传递的，也就是说当前引用的第三方库仅限于本module内使用，其他module需要重新添加依赖才能用
    implementation 'com.google.code.gson:gson:2.8.5'
    implementation 'com.squareup.retrofit2:retrofit:2.5.0'
    implementation 'com.squareup.retrofit2:converter-gson:2.5.0'
    implementation 'com.squareup.retrofit2:adapter-rxjava2:2.5.0'
    implementation 'io.reactivex.rxjava2:rxjava:2.2.4'
    //RxJava 2.0
    implementation 'io.reactivex.rxjava2:rxandroid:2.1.0'
    implementation 'com.android.support:recyclerview-v7:27.1.1'
    //RecyclerView
    implementation 'io.reactivex:rxjava:1.3.8'
    //RxJava 1.0
    implementation 'io.reactivex:rxandroid:1.2.1'
    //RxJava 1.0对应使用的RxAndroid，转换主线程时用到 AndroidSchedulers.mainThread()
    implementation 'com.android.support:design:27.1.1'
}
